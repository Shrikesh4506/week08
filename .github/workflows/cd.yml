name: CD - Deploy to AKS

on:
  # Auto-deploy after CI completes on main
  workflow_run:
    workflows: [ "CI - Build & Test" ]
    types: [ completed ]
    branches: [ main ]

  # Also allow manual deploys
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Override image tag (defaults to CI commit SHA)"
        required: false
      aks_cluster_name:
        description: "AKS cluster name"
        required: true
        default: "shrikesh"
      aks_resource_group:
        description: "AKS resource group"
        required: true
        default: "deakinuni"
      namespace:
        description: "Kubernetes namespace"
        required: true
        default: "sit722-w05"

concurrency:
  group: cd-main
  cancel-in-progress: false

permissions:
  contents: read
  id-token: write  # for Azure OIDC login

env:
  # Registry and image names MUST match CI
  REGISTRY_LOGIN_SERVER: ${{ secrets.REGISTRY_LOGIN_SERVER }}   # e.g. shrikesh.azurecr.io
  BACKEND_IMAGE_NAME: product_service
  FRONTEND_IMAGE_NAME: frontend_app

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Resolve deploy inputs
        id: vars
        run: |
          # If this is workflow_run, derive tag from the CI run's commit (head_sha).
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            TAG="${{ github.event.workflow_run.head_sha }}"
            AKS="${{ env.AKS_CLUSTER_NAME }}"
            RG="${{ env.AKS_RESOURCE_GROUP }}"
            NS="${{ env.K8S_NAMESPACE }}"
          else
            TAG="${{ github.event.inputs.image_tag }}"
            [ -z "$TAG" ] && TAG="${{ github.sha }}"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Set dynamic env
        env:
          TAG: ${{ steps.vars.outputs.tag }}
        run: |
          echo "AKS_CLUSTER_NAME=${{ github.event.inputs.aks_cluster_name || 'shrikesh' }}" >> $GITHUB_ENV
          echo "AKS_RESOURCE_GROUP=${{ github.event.inputs.aks_resource_group || 'deakinuni' }}" >> $GITHUB_ENV
          echo "K8S_NAMESPACE=${{ github.event.inputs.namespace || 'sit722-w05' }}" >> $GITHUB_ENV
          echo "BACKEND_IMAGE=${{ env.REGISTRY_LOGIN_SERVER }}/${{ env.BACKEND_IMAGE_NAME }}:${TAG}" >> $GITHUB_ENV
          echo "FRONTEND_IMAGE=${{ env.REGISTRY_LOGIN_SERVER }}/${{ env.FRONTEND_IMAGE_NAME }}:${TAG}" >> $GITHUB_ENV

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: az aks get-credentials -g "${{ env.AKS_RESOURCE_GROUP }}" -n "${{ env.AKS_CLUSTER_NAME }}" --overwrite-existing

      - name: Ensure namespace exists
        run: |
          kubectl create ns "${{ env.K8S_NAMESPACE }}" --dry-run=client -o yaml | kubectl apply -f -

      # If you maintain manifests, apply them first (adjust paths)
      - name: Apply backend manifests
        run: |
          if [ -f "k8s/backend/deployment.yaml" ]; then
            kubectl apply -f k8s/backend/deployment.yaml -n "${{ env.K8S_NAMESPACE }}"
          fi

      - name: Apply frontend manifests
        run: |
          if [ -f "k8s/frontend/deployment.yaml" ]; then
            kubectl apply -f k8s/frontend/deployment.yaml -n "${{ env.K8S_NAMESPACE }}"
          fi

      # Point deployments to the new immutable images
      - name: Set backend image + rollout
        run: |
          # adjust deployment/name and container name if different
          kubectl set image deploy/product-service product-service="${{ env.BACKEND_IMAGE }}" -n "${{ env.K8S_NAMESPACE }}"
          kubectl rollout status deploy/product-service -n "${{ env.K8S_NAMESPACE }}" --timeout=300s

      - name: Set frontend image + rollout
        run: |
          kubectl set image deploy/frontend frontend="${{ env.FRONTEND_IMAGE }}" -n "${{ env.K8S_NAMESPACE }}"
          kubectl rollout status deploy/frontend -n "${{ env.K8S_NAMESPACE }}" --timeout=300s

      - name: Show services
        run: kubectl get svc -n "${{ env.K8S_NAMESPACE }}" -o wide
